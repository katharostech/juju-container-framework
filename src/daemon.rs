//! Contains the Lucky RPC implementaiton used for client->daemon communication.

#[allow(clippy::all)]
#[allow(bare_trait_objects)]
/// The varlink RPC code ( generated by build.rs from `rpc/lucky.rpc.varlink` )
pub(crate) mod lucky_rpc;
pub(crate) use lucky_rpc as rpc;

use crate::juju::ScriptStatus;

use std::sync::{
    atomic::{AtomicBool, Ordering},
    Arc, RwLock,
};

/// The Lucky Daemon RPC service
struct LuckyDaemon {
    /// Used to indicate that the server should stop listening.
    /// This will be set to true to indicate that the server should stop.
    stop_listening: Arc<AtomicBool>,
}

impl LuckyDaemon {
    /// Create a new daemon instance
    ///
    /// stop_listening will be set to `true` by the daemon if it recieves a StopDaemon RPC. The
    /// actual stopping of the server itself is not handled by the daemon.
    fn new(stop_listening: Arc<AtomicBool>) -> Self {
        LuckyDaemon { stop_listening }
    }
}

impl rpc::VarlinkInterface for LuckyDaemon {
    /// Trigger a Juju hook
    fn trigger_hook(
        &self,
        call: &mut dyn rpc::Call_TriggerHook,
        hook_name: String,
    ) -> varlink::Result<()> {
        log::info!("Triggering hook: {}", hook_name);

        // Reply and exit
        call.set_continues(true);
        call.reply(Some("Hello fello!".into()))?;
        call.reply(Some("Goodbye dude!".into()))?;
        call.set_continues(false);
        call.reply(None)?;
        Ok(())
    }

    /// Stop the Lucky daemon
    fn stop_daemon(&self, call: &mut dyn rpc::Call_StopDaemon) -> varlink::Result<()> {
        // Set the stop_listening=true.
        log::info!("Shutting down server");
        self.stop_listening.store(true, Ordering::SeqCst);

        // Reply and exit
        call.reply()?;
        Ok(())
    }

    /// Set a script's status
    fn set_status(
        &self,
        call: &mut dyn rpc::Call_SetStatus,
        status: rpc::ScriptStatus,
    ) -> varlink::Result<()> {
        let status: ScriptStatus = status.into();
        log::info!("Setting script status: {:?}", status);

        crate::juju::set_status(status).or_else(|e| call.reply_os_error(format!("{}", e)))?;

        call.reply()?;
        Ok(())
    }
}

/// Get the server service
pub(crate) fn get_service(stop_listening: Arc<AtomicBool>) -> varlink::VarlinkService {
    // Create a new daemon instance
    let daemon_instance = LuckyDaemon::new(stop_listening);

    // Return the varlink service
    varlink::VarlinkService::new(
        "lucky.rpc",
        "lucky daemon",
        clap::crate_version!(),
        "https://github.com/katharostech/lucky",
        vec![Box::new(lucky_rpc::new(Box::new(daemon_instance)))],
    )
}

/// Get the client
pub(crate) fn get_client(connection: Arc<RwLock<varlink::Connection>>) -> rpc::VarlinkClient {
    // Return the varlink client
    rpc::VarlinkClient::new(connection)
}
